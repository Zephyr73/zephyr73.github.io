/**
 * galleryImages.js — Eleventy global data file
 * Scans every gallery category, reads EXIF via sharp + exif-reader,
 * and returns an array used by src/gallery/image.njk pagination
 * to generate one detail page per image.
 */

import sharp from 'sharp';
import exifReader from 'exif-reader';
import fs from 'node:fs';
import path from 'node:path';

const GALLERY_ROOT = './src/assets/img/gallery';
const CATEGORIES = ['photography', 'ai', 'forza'];
const IMAGE_RE = /\.(jpe?g|png|webp)$/i;

function formatFileSize(bytes) {
  return bytes >= 1024 * 1024
    ? `${(bytes / (1024 * 1024)).toFixed(1)} MB`
    : `${Math.round(bytes / 1024)} KB`;
}

function formatShutterSpeed(expTime) {
  if (!expTime) return '';
  if (expTime >= 1) return `${expTime}s`;
  const denom = Math.round(1 / expTime);
  return `1/${denom}s`;
}

/** Parse an EXIF date string "YYYY:MM:DD HH:MM:SS" into a JS Date */
function parseExifDate(str) {
  if (!str) return null;
  const s = str.toString();
  const [datePart, timePart] = s.split(' ');
  const [y, m, d] = datePart.split(':');
  const parsed = new Date(`${y}-${m}-${d}T${timePart || '00:00:00'}`);
  return isNaN(parsed.getTime()) ? null : parsed;
}

function formatDate(date, long = false) {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: long ? 'long' : 'short',
    day: 'numeric',
  });
}

export default async function () {
  const images = [];

  for (const category of CATEGORIES) {
    const dir = path.join(GALLERY_ROOT, category);
    if (!fs.existsSync(dir)) continue;

    const files = fs
      .readdirSync(dir)
      .filter((f) => IMAGE_RE.test(f))
      .sort((a, b) => {
        const na = parseInt(a, 10);
        const nb = parseInt(b, 10);
        return isNaN(na) || isNaN(nb) ? a.localeCompare(b) : na - nb;
      });

    for (const file of files) {
      const srcPath = path.join(GALLERY_ROOT, category, file);
      const baseName = path.basename(file, path.extname(file));
      const slug = `${category}-${baseName}`;

      const [meta, stats] = await Promise.all([
        sharp(srcPath).metadata(),
        Promise.resolve(fs.statSync(srcPath)),
      ]);

      const fileSize = formatFileSize(stats.size);
      const resolution = `${meta.width} × ${meta.height}`;

      // ── EXIF ────────────────────────────────────────────────────────────
      let date = '';
      let device = '';
      let lens = '';
      let shutterSpeed = '';
      let aperture = '';
      let iso = '';
      let focalLength = '';

      const fileDate = stats.birthtime < stats.mtime ? stats.birthtime : stats.mtime;

      if (meta.exif) {
        try {
          const exif = exifReader(meta.exif);
          const img = exif.Image ?? {};
          const photo = exif.Photo ?? {};

          // Device
          const make = img.Make?.trim() ?? '';
          const model = img.Model?.trim() ?? '';
          if (make && model) {
            device = model.toLowerCase().startsWith(make.toLowerCase())
              ? model
              : `${make} ${model}`;
          } else {
            device = model || make;
          }

          // Lens
          lens = photo.LensModel?.trim() || img.LensMake?.trim() || '';

          // Camera settings
          shutterSpeed = formatShutterSpeed(photo.ExposureTime);
          if (photo.FNumber) aperture = `f/${photo.FNumber}`;
          const isoVal = Array.isArray(photo.ISOSpeedRatings)
            ? photo.ISOSpeedRatings[0]
            : photo.ISOSpeedRatings;
          if (isoVal) iso = `ISO ${isoVal}`;
          if (photo.FocalLength) focalLength = `${photo.FocalLength}mm`;

          // Date — prefer oldest of EXIF date and file date
          const exifDate =
            parseExifDate(photo.DateTimeOriginal) ??
            parseExifDate(photo.DateTimeDigitized) ??
            parseExifDate(img.DateTime);
          const resolvedDate = exifDate && exifDate < fileDate ? exifDate : fileDate;
          date = formatDate(resolvedDate, true);
        } catch {
          date = formatDate(fileDate, true);
        }
      } else {
        date = formatDate(fileDate, true);
      }

      // Thumbnail URL uses the 800w WebP generated by eleventy-img
      // Full-res display/download URL = largest generated JPEG width that
      // actually exists (eleventy-img skips widths larger than the original)
      const GENERATED_WIDTHS = [400, 800, 1200, 1800];
      const largestWidth = [...GENERATED_WIDTHS].reverse().find((w) => w <= meta.width) ?? GENERATED_WIDTHS[0];
      const thumbUrl = `/assets/img/gallery/${category}/${baseName}-800w.webp`;
      const fullUrl = `/assets/img/gallery/${category}/${baseName}-${largestWidth}w.jpeg`;

      images.push({
        slug,
        category,
        filename: file,
        thumbUrl,
        fullUrl,
        downloadFilename: file,
        resolution,
        fileSize,
        date,
        device,
        lens,
        shutterSpeed,
        aperture,
        iso,
        focalLength,
      });
    }
  }

  return images;
}
